// TabMachine.cpp
#include "tab_machine.hpp"
#include "interface.hpp"
#include "lv_style.hpp"
#include "handwheel_slider.h"
#include "tab_jog.hpp"
#include "file_list.hpp"
#include "machine_position.hpp"
#include "dialogs.hpp"

#include <iostream> //Used for Serial out

// Define constants outside the class
const std::map<std::string, std::map<std::string, std::vector<double>>> MachineStatusMeter::CHIP_LOAD_RANGES = {
  {"Aluminium", {
    {"1/8\"", {0.075, 0.1}},
    {"3mm", {0.075, 0.1}},
    {"1/4\"", {0.125, 0.175}},
    {"6mm", {0.125, 0.175}},
    {"3/8\"", {0.15, 0.2}},
    {"10mm", {0.15, 0.2}},
    {"1/2\"", {0.15, 0.2}},
    {"12mm", {0.2, 0.25}}
  }},
  {"Hard Wood", {}},
  {"MDF", {}},
  {"Soft Wood", {}},
  {"Acrylic", {}},
  {"Hard Plastic", {}},
  {"Soft Plastic", {}}
};

TabMachine::TabMachine(lv_obj_t* tabv, Interface* interface, lv_obj_t* tab) : tab(tab)
{
    this->tab = tab;
    this->interface = interface;

    tab = this->tab;
    flex_col(tab);

    this->init_machine_tabv(tab);
    this->init_axis_float_btn();
}

void TabMachine::init_axis_float_btn() {
    JogDial* jog_dial = this->interface->tab_jog->jog_dial;

    this->float_btn = lv_button_create(this->tab);
    lv_obj_set_size(this->float_btn, 45, 45);
    lv_obj_add_flag(this->float_btn, LV_OBJ_FLAG_FLOATING);
    lv_obj_align(this->float_btn, LV_ALIGN_BOTTOM_RIGHT, 0, 0);
    lv_obj_t* label = lv_label_create(this->float_btn);
    lv_label_set_text(label, jog_dial->current_axis().c_str());
    lv_obj_center(label);

    lv_obj_add_event_cb(this->float_btn, [](lv_event_t* e) {
      TabMachine* self = (TabMachine*)lv_obj_get_user_data(lv_event_get_target(e));
      JogDial* jog_dial = self->interface->tab_jog->jog_dial;
      lv_label_set_text(lv_obj_get_child(lv_event_get_target(e), 0), jog_dial->next_axis().c_str());
    }, LV_EVENT_CLICKED, this); // Store 'this' in user_data

    jog_dial->add_axis_change_db([label](const std::string& t) {
        lv_label_set_text(label, t.c_str());
    });

    style(this->float_btn, {{"radius", LV_RADIUS_CIRCLE}});
}

void TabMachine::init_machine_tabv(lv_obj_t* parent) {
    this->main_tabs = lv_tabview_create(parent);

    style_pad(parent, 5);

    lv_obj_t* tabv = this->main_tabs;

    this->tab_status = lv_tabview_add_tab(tabv, "Status");
    this->tab_macros = lv_tabview_add_tab(tabv, "Macros");
    this->tab_jobs = lv_tabview_add_tab(tabv, "Jobs");

    lv_obj_remove_flag(lv_tabview_get_content(tabv), LV_OBJ_FLAG_SCROLLABLE);
    lv_tabview_set_tab_bar_position(tabv, LV_DIR_BOTTOM);
    lv_tabview_set_tab_bar_size(tabv, this->interface->TAB_HEIGHT);

    non_scrollable(this->tab_status);
    non_scrollable(this->tab_jobs);
    non_scrollable(this->tab_macros);

    this->init_tab_status(this->tab_status);
    this->init_tab_jobs(this->tab_jobs);
    this->init_tab_macros(this->tab_macros);
}

void TabMachine::init_tab_status(lv_obj_t* tab) {
    this->mach_meter = new MachineStatusMeter(tab, this->interface, 16000, 6000);
    lv_obj_set_size(this->mach_meter, LV_PCT(100), LV_PCT(100));
}

void TabMachine::_gcode_clicked(const std::string& file) {
    auto lambda1 = [this, file]() {
        std::cout << "calling interface->machine->start_job()" << std::endl;
        this->interface->machine->start_job(file);
    };

    ui::button_dialog(
            "Run Job?",
            ("Start job \"" + file + "\" now?").c_str(),
            true,
            {"Yes", "No"},
            {lambda1, nullptr}
            );
}

void TabMachine::_macro_clicked(const std::string& file) {
    auto lambda2 = [this, file]() {
        std::cout << "calling interface->machine->run_macro()" << std::endl;
        this->interface->machine->run_macro("/macros/" + file);
    };

    ui::button_dialog(
            "Run Macro?",
            ("Start macro \"" + file + "\" now?").c_str(),
            true,
            {"Yes", "No"},
            {lambda2, nullptr}
            );
}

void TabMachine::init_tab_jobs(lv_obj_t* tab) {
    this->jobs_list = new file_list(tab, "gcodes", this->interface,
                                       [this](const std::string& file) { _gcode_clicked(file); });

    lv_obj_t* jl = this->jobs_list;
    lv_obj_set_size(jl, LV_PCT(100), LV_PCT(100));
    no_margin_pad_border(tab);
    no_margin_pad_border(jl);
}

void TabMachine::init_tab_macros(lv_obj_t* tab) {
    this->macro_list = new file_list(tab, "macros", this->interface,
                                        [this](const std::string& file) { _macro_clicked(file); });

    lv_obj_t* jl = this->macro_list;
    lv_obj_set_size(jl, LV_PCT(100), LV_PCT(100));
    no_margin_pad_border(tab);
    no_margin_pad_border(jl);
}

// Add forward declaration for MachinStatusMeter here, before it's used.
//const std::map<std::string, std::map<std::string, std::vector<double>>> MachineStatusMeter::CHIP_LOAD_RANGES = {
//  {"Aluminium", {
//    {"1/8\"", {0.075, 0.1}},
//    {"3mm", {0.075, 0.1}},
//    {"1/4\"", {0.125, 0.175}},
//    {"6mm", {0.125, 0.175}},
//    {"3/8\"", {0.15, 0.2}},
//    {"10mm", {0.15, 0.2}},
//    {"1/2\"", {0.15, 0.2}},
//    {"12mm", {0.2, 0.25}}
//  }},
//  {"Hard Wood", {}},
//  {"MDF", {}},
//  {"Soft Wood", {}},
//  {"Acrylic", {}},
//  {"Hard Plastic", {}},
//  {"Soft Plastic", {}}
//};

MachineStatusMeter::MachineStatusMeter(lv_obj_t* parent, Interface* interface, int spindle_max_rpm, int max_feed) : lv_obj_t(parent){
    style(this, {{"border_width", 0}, {"padding", 0}, {"margin", 0}});
    style(parent, {{"border_width", 0}, {"padding", 0}, {"margin", 0}});

    this->spindle_max_rpm = spindle_max_rpm / 100 * 100;
    this->max_feed = max_feed / 100 * 100;
    this->interface = interface;

    flex_row(this);
    lv_obj_set_style_pad_row(this, 0, LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(this, 0, LV_STATE_DEFAULT);

    this->left_side = container_col(this,0,0);
    lv_obj_set_flex_grow(this->left_side, 5);
    lv_obj_set_height(this->left_side, LV_SIZE_CONTENT);
    style(this->left_side, {{"bg_opa", 0}, {"border_width", 0}, {"padding", 5}});
    lv_obj_set_style_text_font(this->left_side, &lv_font_montserrat_12, LV_STATE_DEFAULT);

    this->right_side = lv_obj_create(this);
    lv_obj_set_height(this->right_side, LV_PCT(100));
    lv_obj_set_width(this->right_side, LV_SIZE_CONTENT);

    flex_row(this->right_side, 0, 0, true);
    lv_obj_set_flex_align(this->right_side, LV_FLEX_ALIGN_SPACE_EVENLY, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_START);
    style(this->right_side, {{"bg_opa", 0}, {"border_width", 0}, {"padding", {0, 10, 0, 0}}, {"margin", 0}});
    lv_obj_set_style_text_font(this->right_side, &lv_font_montserrat_12, LV_STATE_DEFAULT);
    non_scrollable(this->right_side);

    lv_obj_t* label_feed = lv_label_create(this->left_side);
    lv_label_set_text(label_feed, "Feed (mm/min):");
    this->bar_feed = lv_bar_create(this->left_side);
    lv_bar_set_range(this->bar_feed, 0, this->max_feed);
    no_margin_pad_border(this->bar_feed);
    style(this->bar_feed, {{"padding", {5, 18}}, {"bg_opa", 0}});
    lv_obj_set_height(this->bar_feed, 18);
    lv_obj_set_width(this->bar_feed, LV_PCT(100));
    lv_obj_set_style_margin_bottom(this->bar_feed, 0, LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(this->bar_feed, 0, LV_STATE_DEFAULT);
    lv_obj_add_flag(this->bar_feed, LV_OBJ_FLAG_ADV_HITTEST);

    lv_style_t style_indic;
    lv_style_init(&style_indic);
    lv_style_set_bg_opa(&style_indic, LV_OPA_COVER);
    lv_style_set_bg_color(&style_indic, lv_color_make(0, 220, 0));
    lv_style_set_bg_grad_color(&style_indic, lv_color_make(0, 0, 220));
    lv_style_set_bg_grad_dir(&style_indic, LV_GRAD_DIR_HOR);
    lv_style_set_bg_main_stop(&style_indic, 175);
    lv_obj_add_style(this->bar_feed, &style_indic, LV_PART_INDICATOR);
    lv_bar_set_value(this->bar_feed, 5000, LV_ANIM_ON);
    lv_obj_set_style_radius(this->bar_feed, 3, LV_PART_MAIN);
    lv_obj_set_style_radius(this->bar_feed, 3, LV_PART_INDICATOR);

    this->scale_feed = lv_scale_create(this->left_side);
    lv_obj_set_style_margin_top(this->scale_feed, 0, LV_STATE_DEFAULT);
    no_margin_pad_border(this->scale_feed);
    style(this->scale_feed, {{"margin", {0, 18}}});
    lv_obj_set_style_pad_top(this->scale_feed, 0, LV_STATE_DEFAULT);
    lv_scale_set_mode(this->scale_feed, LV_SCALE_MODE_HORIZONTAL_BOTTOM);
    lv_scale_set_total_tick_count(this->scale_feed, this->max_feed / 1000 + 1);
    lv_scale_set_major_tick_every(this->scale_feed, 1);
    lv_scale_set_label_show(this->scale_feed, true);
    lv_scale_set_range(this->scale_feed, 0, this->max_feed / 1000);
    lv_obj_set_height(this->scale_feed, 30);
    lv_obj_set_width(this->scale_feed, LV_PCT(100));

    lv_obj_t* label_spindle_rpm = lv_label_create(this->left_side);
    lv_label_set_text(label_spindle_rpm, "Spindle (RPM):");
    lv_obj_set_style_text_font(label_spindle_rpm, &lv_font_montserrat_12, LV_STATE_DEFAULT);
    HandwheelSlider* slider_spindle_rpm = new HandwheelSlider(this->left_side, this->interface);
    lv_slider_set_range(slider_spindle_rpm, 0, this->spindle_max_rpm);
    no_margin_pad_border(slider_spindle_rpm);
    style(slider_spindle_rpm, {{"margin", {0, 18}}});
    lv_obj_set_height(slider_spindle_rpm, 18);
    lv_obj_set_width(slider_spindle_rpm, LV_PCT(100));
    lv_obj_set_style_margin_bottom(slider_spindle_rpm, 0, LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(slider_spindle_rpm, 0, LV_STATE_DEFAULT);
    lv_obj_add_flag(slider_spindle_rpm, LV_OBJ_FLAG_ADV_HITTEST);
    lv_obj_add_style(slider_spindle_rpm, &style_indic, LV_PART_INDICATOR);
    lv_obj_set_style_radius(slider_spindle_rpm, 3, LV_PART_MAIN);

    this->scale_spindle_rpm = lv_scale_create(this->left_side);
    lv_scale_set_mode(this->scale_spindle_rpm, LV_SCALE_MODE_HORIZONTAL_BOTTOM);
    lv_scale_set_total_tick_count(this->scale_spindle_rpm, this->spindle_max_rpm / 1000 + 1);
    no_margin_pad_border(this->scale_spindle_rpm);
    style(this->scale_spindle_rpm, {{"margin", {0, 18}}});
    lv_scale_set_major_tick_every(this->scale_spindle_rpm, 5);
    lv_scale_set_label_show(this->scale_spindle_rpm, true);
    lv_scale_set_range(this->scale_spindle_rpm, 0, this->spindle_max_rpm / 1000);
    lv_obj_set_height(this->scale_spindle_rpm, 30);
    lv_obj_set_width(this->scale_spindle_rpm, LV_PCT(100));

    // Material and End Mill Dropdowns.
    lv_obj_t* mat_end_container = container_row(this->left_side, 0, 0);
    lv_obj_set_style_pad_bottom(mat_end_container, 5, LV_STATE_DEFAULT);
    this->material_dd = lv_dropdown_create(mat_end_container);
    std::string matOptions;
    for (auto const& [key, val] : CHIP_LOAD_RANGES) {
      matOptions += key + "\n";
    }
    lv_dropdown_set_options(this->material_dd, matOptions.c_str());
    lv_obj_set_width(this->material_dd, LV_PCT(40));

    this->mill_dd = lv_dropdown_create(mat_end_container);
    lv_obj_set_width(this->mill_dd, LV_PCT(25));

    lv_obj_add_event_cb(this->material_dd, [](lv_event_t* e) {
        MachineStatusMeter* self = (MachineStatusMeter*)lv_obj_get_user_data(lv_event_get_target(e));
        self->_mat_dd_change(e);
    }, LV_EVENT_VALUE_CHANGED, this);

    lv_obj_add_event_cb(this->mill_dd, [](lv_event_t* e) {
        MachineStatusMeter* self = (MachineStatusMeter*)lv_obj_get_user_data(lv_event_get_target(e));
        self->_mill_dd_change(e);
    }, LV_EVENT_VALUE_CHANGED, this);

    this->_mat_dd_change(nullptr);

    this->flute_dd = lv_dropdown_create(mat_end_container);
    lv_obj_set_width(this->flute_dd, LV_PCT(25));
    lv_dropdown_set_options(this->flute_dd, "1F\n2F\n3F\n4F");

    // Chip Load.
    lv_obj_t* chip_ld_container = container_col(this->left_side, 0, 0);
    lv_obj_set_height(chip_ld_container, 60);
    non_scrollable(chip_ld_container);
    style(chip_ld_container, {{"padding", {0, 18}}});

    // Label.
    lv_obj_t* label_spindle_chip = lv_label_create(chip_ld_container);
    lv_label_set_text(label_spindle_chip, "Chip Load (x0.1mm)");
    lv_obj_set_width(label_spindle_chip, LV_SIZE_CONTENT);

    // Chip Load Meter Container.
    lv_obj_t* chip_ldmc = container_col(chip_ld_container, 0, 0);
    lv_obj_set_flex_grow(chip_ldmc, 1);
    non_scrollable(chip_ldmc);
    style(chip_ldmc, {{"padding", {0, 18}}});

    // Chip Load Bar.
    double cl_min = 0.3;
    double cl_max = 0.5;

    this->bar_cl = lv_bar_create(chip_ldmc);
    lv_bar_set_range(this->bar_cl, 0, 50);
    no_margin_pad_border(this->bar_cl);
    style(this->bar_cl, {{"padding", {5, 0}}, {"bg_opa", 0}});
    lv_obj_set_height(this->bar_cl, 18);
    lv_obj_set_width(this->bar_cl, LV_PCT(100));
    lv_obj_set_style_margin_bottom(this->bar_cl, 0, LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(this->bar_cl, 0, LV_STATE_DEFAULT);
    lv_obj_add_flag(this->bar_cl, LV_OBJ_FLAG_ADV_HITTEST);

    lv_style_t style_barc;
    lv_style_init(&style_barc);
    lv_style_set_bg_opa(&style_barc, LV_OPA_COVER);
    lv_style_set_bg_color(&style_barc, lv_color_make(0, 220, 0));
    lv_style_set_bg_grad_color(&style_barc, lv_color_make(0, 0, 220));
    lv_style_set_bg_grad_dir(&style_barc, LV_GRAD_DIR_HOR);
    lv_style_set_bg_main_stop(&style_barc, round(255 * cl_min));
    lv_style_set_bg_grad_stop(&style_barc, round(255 * cl_max));
    lv_obj_add_style(this->bar_cl, &style_barc, LV_PART_INDICATOR);
    lv_bar_set_value(this->bar_cl, 35, LV_ANIM_ON);
    lv_obj_set_style_radius(this->bar_cl, 3, LV_PART_MAIN);
    lv_obj_set_style_radius(this->bar_cl, 3, LV_PART_INDICATOR);
    lv_obj_set_style_bg_opa(this->bar_cl, 0, LV_STATE_DEFAULT);

    // Chip Load Scale.
    this->scale_spindle_chipload = lv_scale_create(chip_ldmc);
    lv_scale_set_mode(this->scale_spindle_chipload, LV_SCALE_MODE_HORIZONTAL_BOTTOM);
    lv_scale_set_total_tick_count(this->scale_spindle_chipload, 11);
    lv_scale_set_major_tick_every(this->scale_spindle_chipload, 5);
    lv_scale_set_label_show(this->scale_spindle_chipload, true);
    lv_scale_set_range(this->scale_spindle_chipload, 0, 50);
    lv_obj_set_height(this->scale_spindle_chipload, 30);
    lv_obj_set_width(this->scale_spindle_chipload, LV_PCT(100));
    no_margin_pad_border(this->scale_spindle_chipload);
    lv_obj_add_style(this->scale_spindle_chipload, &style_barc, LV_PART_INDICATOR);

    auto style_sec = [](lv_obj_t* bar, int low, int high, lv_color_t color) {
        lv_style_t st;
        lv_style_init(&st);
        lv_style_set_line_color(&st, color);
        lv_style_set_bg_color(&st, color);
        lv_scale_section_dsc_t* sec = lv_scale_add_section(bar);
        lv_scale_section_set_range(sec, low, high);
        lv_scale_section_set_style(sec, LV_PART_INDICATOR, &st);
        lv_scale_section_set_style(sec, LV_PART_ITEMS, &st);
        lv_style_t stm;
        lv_style_init(&stm);
        lv_style_set_line_color(&stm, color);
        lv_style_set_bg_color(&stm, color);
        lv_scale_section_set_style(sec, LV_PART_MAIN, &stm);
    };

    style_sec(this->scale_spindle_chipload, 0, round(50 * cl_min), lv_color_make(0, 120, 120));
    style_sec(this->scale_spindle_chipload,
              round(50 * cl_min),
              round(50 * cl_max),
              lv_color_make(0, 220, 0));
    style_sec(this->scale_spindle_chipload, round(50 * cl_max), 50,
              lv_color_make(0, 0, 220));

    this->update_layout();
    lv_obj_update_layout(this->left_side);

    // Machine Coordinates.
    std::vector<std::string> coords = MachinePositionWCS::DEFAULT_COORD_SYSTEMS;
    coords.pop_back();
    this->axes = JogDial::AXES;
    this->position = new MachinePositionWCS(this->right_side, this->axes,
                                       this->interface, 6,
                                       coords);

    lv_obj_align_to(this->position, this->right_side, LV_ALIGN_TOP_MID, 0, 0);
    lv_obj_set_style_margin_top(this->position, 20, LV_STATE_DEFAULT);

    for (size_t i = 0; i < this->axes.size(); ++i) {
        lv_obj_t* btn = lv_button_create(this->right_side);
        lv_obj_t* lbl = lv_label_create(btn);
        std::string btnText = std::string(LV_SYMBOL_REFRESH) + " Zero WCS " + this->axes[i];
        lv_label_set_text(lbl, btnText.c_str());
        lv_obj_set_size(btn, 150, 25);
        lv_obj_center(lbl);
        MachineInterface* machine = this->interface->machine;

        lv_obj_add_event_cb(btn, [](lv_event_t* e) {
              lv_obj_t* btn = lv_event_get_target(e);
              MachineStatusMeter* self = (MachineStatusMeter*)lv_obj_get_user_data(btn);
              MachineInterface* machine = self->interface->machine;
              size_t i = (size_t)lv_obj_get_index(btn);
              machine->set_wcs_zero(machine->wcs, {self->axes[i]});
          }, LV_EVENT_CLICKED, this);

        lv_obj_add_flag(btn, LV_OBJ_FLAG_FLEX_IN_NEW_TRACK);
        lv_obj_set_user_data(btn, this);
        lv_obj_set_index(btn, i);
        this->set_wcs_btns.push_back(btn);
    }
}

void MachineStatusMeter::_mill_dd_change(lv_event_t* e) {
    //TODO: Implement
}

void MachineStatusMeter::_mat_dd_change(lv_event_t* e) {
  int selected = lv_dropdown_get_selected(this->material_dd);
  std::string material;
  int i = 0;
    for (auto const& [key, val] : CHIP_LOAD_RANGES) {
      if (i == selected) {
        material = key;
        break;
      }
      i++;
    }

  const auto& mills = CHIP_LOAD_RANGES.at(material);
  std::string millOptions;
  for (auto const& [key, val] : mills) {
    millOptions += key + "\n";
  }
  lv_dropdown_set_options(this->mill_dd, millOptions.c_str());
}